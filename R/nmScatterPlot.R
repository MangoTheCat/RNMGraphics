# $Rev$
# $LastChangedDate$


#' Generates a set of scatter plots with features that are tailored for PK/PD data generated by NONMEM.
#' @name nmScatterPlot
#' @title NONMEM scatter plot
#' @param obj An object of class NMRun, NMProblem, or data.frame. The object from which data will be plotted.
#' @param xVars A character vector or comma-seperated string of x-variables. Names of the variables to plot on x-axes.
#' @param yVars Variables to plot on the y-axes, specified the same way as xVars
#' @param bVars “Trellis” variables on which to split data.  Will be recycled for each x/y variable pair.
#' @param gVars “Grouping” variable – used to group points by colour, for legends and so on.  
#' Will be recycled for each x/y variable pair.
#' @param iVars Variable name of the “inherent grouping” variable.  This affects plots whose type is "l", "i" or "t".
#' @param addLegend Should legends be added?
#' @param addGrid should grids be added?
#' @param addLoess should a loess smoother line be added? 
#' @param titles Plot title for each x/y pair.  Optional
#' @param logX Should the x-axis be logged?  Recycled for each x/y pair 
#' @param logY similar to logX for y axis
#' @param idLines Should reference lines of slope 1 and y-intercept 0 be added? Recycled for each x/y pair
#' @param abLines Unused at the moment.
#' @param xLab x-axis labels.  By default, will use the names of the x-axis variables and their descriptions if any are available
#' via getVarDescription in RNMImport
#' @param yLab similar to the above, but for y-axis labels
#' @param doPlot Should the plot be plotted immediately, before returning it as an object?
#' @param types Plot types to use for each x/y pair.  Allowed types are "p" (for standard points), "l" (lines connected by the variable
#' specified in "iVars", "i" for points labeled by "iVars", and "t" for labels connected by lines grouped by "iVars"
#' @param overlaid Logical flag.  If TRUE, for each fixed x, the y variables will be overlaid onto a single plot
#' @param problemNum
#' @param subProblems
#' @param equalAxisScales
#' @param equaltYScales
#' @param ... Additonal variables passed to the xyplot function 
#' @return An object of class multiTrellis holding the plot
#' @author fgochez
#' @keywords hplot

# TODO: take out "doPlot" (code review)

nmScatterPlot <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="", logX = NULL,
		logY = NULL, idLines = FALSE, abLines = NULL, xLab = NULL, yLab = NULL, 
		types = "p", overlaid = FALSE, equalAxisScales = FALSE, equalYScales = TRUE,
		xBin = Inf, layout = NULL, maxPanels = NULL, maxTLevels = Inf, 
		yAxisRelations = c("same", "free", "sliced"),
		problemNum = 1, subProblems = 1,
		...)
{
	RNMGraphicsStop("Not implemented for this class yet!")
}	
setGeneric("nmScatterPlot")

nmScatterPlot.NMRun <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="" , 
							logX = FALSE, logY = FALSE,idLines = FALSE,  abLines = NULL, xLab = NULL, 
							yLab = NULL, types = "p", overlaid = FALSE, equalAxisScales = FALSE ,
							equalYScales = TRUE, xBin = Inf, layout = NULL, maxPanels = NULL, 
							maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"), problemNum = 1, subProblems = 1, ...)
{
	prob <- getProblem(obj, problemNum)
	x <- as.list(match.call())
	x$obj <- prob
	do.call(nmScatterPlot, x[-1])
	
}

setMethod("nmScatterPlot", signature(obj = "NMRun"), nmScatterPlot.NMRun)


nmScatterPlot.NMProblem <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
							logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,xLab =NULL , yLab = NULL, 
							types = "p",  overlaid = FALSE, equalAxisScales = FALSE,  
							equalYScales = TRUE, xBin = Inf,layout = NULL, maxPanels = NULL , 
							maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"),
							problemNum = 1, subProblems = 1,
							...)
{
	
	dataSet <- applyGraphSubset(nmData(obj, subProblemNum = subProblems), graphSubset(obj))
	x <- as.list(match.call())
	x$obj <- dataSet

	do.call(nmScatterPlot, x[-1])
	
}

# TODO: implement multiple grouping variables
# TODO: repetition of legend for each plot doesn't look great, but is difficult to solve. Consider
# moving this using grid graphics

nmScatterPlot.data.frame <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
		logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,  xLab = NULL, 
		yLab = NULL,  types = "p", overlaid = FALSE , 
		 equalAxisScales = FALSE, equalYScales = TRUE,xBin = Inf, layout = NULL, maxPanels = NULL ,  
		 maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"), 
		 problemNum = 1, subProblems = 1, ...)
{
	if(length(maxPanels) > 0) layout <- NULL
	# ensure that maxPanels is numeric, even if empty
	else maxPanels <- numeric(0)
	
	xVars <- CSLtoVector(xVars)
	RNMGraphicsStopifnot(length(xVars) == 1, msg = "Multiple x variables are not allowed at the moment\n")
	yVars <- CSLtoVector(yVars)
	# TODO eliminate this copy
	dataSet <- applyGraphSubset(obj, graphSubset(obj))
	
	if(overlaid)
	{
		return(.overlaidScatter(obj =dataSet, xVars = xVars, yVars = yVars, bVars = bVars, 
						gVars = gVars, iVars = iVars, 
						addLegend = addLegend, addGrid = addGrid,
						addLoess = addLoess, titles = titles, logX = logX, 
						logY = logY, idLines = idLines, xLab = xLab,
						yLab = yLab, types = types, equalAxisScales = equalAxisScales,
						maxPanels = maxPanels, layout = layout, maxTLevels = maxTLevels, ...))
	}
	# bin the xVariable if it has more than a certain number of levels, and then use boxplot if this is the case.  Note:
	# TODO: move this behaviour into a different package!
	# TODO: UNITTESTS
	if(length(unique(obj[,xVars])) > xBin)
	{
		newObj <- addDerivedCategorical(obj, xVars, paste(xVars, "CUT", sep = "."), breaks = xBin)
		return(nmBoxPlot(newObj, contVar = yVars, factVar = paste(xVars, "CUT", sep = "."), xLabs =NULL, yLabs = NULL,
						ovelaid = overlaid, titles = titles, bVars = bVars))
	}
	# take all combinations of x variables against y variables
	varCombos <- varComboMatrix(xVars, yVars)
	numCombos <- nrow(varCombos)
	
	gVars <- if(!is.null(gVars)) CSLtoVector(gVars) else "NULL"
	# At the moment, only one gVar handled
	gVars <- gVars[1]
	titles <- rep(titles,numCombos)

	# assign and y labels, taking care to handle the case where they are missing
	# TODO: There is a quirk here in that xLab and yLab _cannot_ be a comma seperated list since empty strings
	# are currently deleted by CSLtoVector.  A workaround is needed for this, and documentation should
	# make clear thet CSLs are not allowed
	if(!is.null(xLab))
		xLab <- rep(xLab, length.out = numCombos)
	else
		xLab <- varCombos[,1]
	if(!is.null(yLab))
		yLab <- rep(yLab, length.out = numCombos)
	else
		yLab <- varCombos[,2]
	
	# repeat these variables so that there is one entry for each combination. 
	repeatVars(c("addLegend", "addGrid", "addLoess", "titles", "logX", "logY", "idLines","types", "equalAxisScales"),
				list(addLegend, addGrid, addLoess, titles, logX, logY, idLines ,types, equalAxisScales), length.out = numCombos )
	# retrieve iVar
	iVars <- if(!is.null(iVars)) rep(CSLtoVector(iVars), length.out = numCombos) else rep("NULL", length.out = numCombos)
	
	plotFormulas <- apply(cbind(varCombos[,2], varCombos[,1] ), 1, paste, collapse = "~")
	# if there are "by variables", adjust the plotting formuals passed to xyplot
	if(!is.null(bVars))
	{
		bVars <- CSLtoVector(bVars)
		temp <- processTrellis(dataSet, bVars, maxLevels = maxTLevels, exempt = iVars)
		bVars <- temp$columns
		# coerce each "by" variable to a factor
		dataSet <- coerceToFactors(temp$data, bVars)
		plotFormulas <- sapply(1:numCombos, function(i) paste(plotFormulas[i], paste(bVars, collapse = "+"), sep = "|"))
	}
	plotList <- vector(mode = "list", length = numCombos)
	graphParams <- getAllGraphParams()
	# This function is used in order to allow for "NULL" x and y labels
	
	par.settings <- mapTopar.settings()
	stripfn <- getStripFun()
	# at the moment, maxPanels overrides the layout
	
	for(i in seq_along(plotFormulas))
	{
		if(addLegend[i] & gVars != "NULL")
		{
			plotKey <- scatterPlotKey(getVarLabel(gVars), dataSet[[gVars]], type = types[i])
					# list(title = getVarDescription(gVars)$Label, rows = 10, cex=.7, space="right")
		}
		else plotKey <- NULL
		
		# get idLabels.  Note that these will have to be repeated if there is more than one yvar
		idLabels <- if(iVars[i] == "NULL") NULL else rep(dataSet[[iVars[i]]], length(yVars) ) 
		
		scales <- list(x = list(), y = list())
		# log axes if necessary
		# TODO: update for multiple y vars
		if(logX[i]) scales$x <- list(log = "e", at = pretty(dataSet[[xVars[i]]]))
		if(logY[i]) scales$y <- list(log = "e", at = pretty(dataSet[[yVars[1]]]))
		# Set axes equal if required
		# TODO check that this really works with multiple y axes
		if (equalAxisScales[i]) scales$limits <- range(unlist(dataSet[c(xVars[i], yVars)]), na.rm=T)
		if(length(yVars) > 1 || length(bVars) > 0) scales$y$relation <- match.arg(yAxisRelations)
		featuresToAdd <- c("grid" = addGrid[i], "loess" = addLoess[i], "idLine" = idLines[i])
		
		plotList[[i]] <- 
				with(graphParams, 
					xyplot(as.formula(plotFormulas[[i]]), groups = eval(parse(text = gVars)),  
					data = dataSet, panel = panel.nmScatterPlot, featuresToAdd = featuresToAdd, 
					key = plotKey, main = titles[[i]], idLabels = idLabels, scales =scales,
					xlab = xLab[i],	ylab = yLab[i],	type = types[i], 
					# TODO: move this logic out of the loop.  Also, wrap this in a function
					par.settings = par.settings, outer = TRUE, stack = FALSE, strip = stripfn, 
					layout = layout, multiYVar = length(yVars) > 1,...)
 				) # end with
	}
	gridDims <- stdGridDims(numCombos,3 )
	result <- multiTrellis(plotList, gridDims, maxPanels = maxPanels)
	result
}


setMethod("nmScatterPlot", signature(obj = "data.frame"), nmScatterPlot.data.frame)

setMethod("nmScatterPlot", signature(obj = "NMProblem"), nmScatterPlot.NMProblem)

# TODO: gVar not implemented correctly for all types other than "p"

panel.nmScatterPlot <- function(x, y, subscripts = seq_along(x), featuresToAdd =  c("grid" = FALSE, "loess" = FALSE, "idLine" = FALSE), 
		idLabels = NULL, type = c("p", "i", "l", "o","t"), groups = NULL, multiYVar = FALSE, ...)
{
	type <- match.arg(type)
	# call panel.xyplot to setup first
	panel.xyplot(x, y, type = "n",...)
	if(featuresToAdd["grid"])
	{
		gridOpts <- getGraphParams("grid")
		panel.grid(h = -1, v = -1, col = gridOpts$col, alpha = gridOpts$alpha, lty = gridOpts$lty, 
					lwd = gridOpts$lwd)
	}
	reflineOpts <- getGraphParams("refline")
	if(featuresToAdd["idLine"])
		panel.abline(a = 0, b = 1)
	
	# grab "superpose.line" styles
	superpose.line.col <- getGraphParams("superpose.line")$col
	
	# TODO: add more comments
	if(type == "p")
	{

		panel.xyplot(x = x, y = y, subscripts = subscripts, type = type, groups,
					...)
	}
	# TODO: capture all line parameters
	else if(type == "l")
	{		
		groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line"))	
		if(is.null(groups))
		{
			plot.line <- getGraphParams("plot.line")
			panel.superpose(x, y, groups = idLabels, type = type, subscripts = subscripts, 
				col.line = plot.line$col, col.lwd = plot.line$lwd, lty = plot.line$lty, ...)
		}
		else
		{
			panel.superpose(x, y, groups = groupInfo$grouping, type = type, subscripts = subscripts, 
					col.line = groupInfo$elements$col, lty = groupInfo$elements$lty, lwd = groupInfo$elements$lwd, ...)
		}
			
	}
	# lines + points connecting subjects
	else if(type == "o")
	{
		RNMGraphicsStopifnot(!is.null(idLabels))
		groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line") )
		
		if(is.null(groups))
		{
			plot.line <- getGraphParams("plot.line")
			panel.xyplot(x, y, type = "p", subscripts = subscripts, ...)
			panel.superpose(x, y, groups = idLabels, 
				type = "l", subscripts = subscripts, col = plot.line$col, 
				lty = plot.line$lty, lwd = plot.line$lwd, ...)
		}
		else
		{
			panel.superpose(x, y, groups = groups, type = "p", subscripts = subscripts, ...)
			panel.superpose(x, y, groups = groupInfo$grouping, type = "l", subscripts = subscripts, 
					col.line = groupInfo$elements$col, lty = groupInfo$elements$lty, lwd = groupInfo$elements$lwd, ...)
		}
	}
	# subject identifiers
	else if(type == "i")
	{
		# TODO: allow use of "gVar"
		RNMGraphicsStopifnot(!is.null(idLabels))
		if(!is.null(groups))
		{
			textopt <- getGraphParams("superpose.text")
			groupInfo <- subjectGrouping(idLabels, groups, textopt, expand = TRUE)
			ltext(x, y, idLabels[subscripts], col = groupInfo$elements$col[subscripts] , cex = groupInfo$elements$cex[subscripts] , ...)
		}
		else
		{
			textopt <- getGraphParams("plot.text")
			ltext(x, y, idLabels[subscripts], col = textopt$col , cex = textopt$cex , ...)
		}
	}
	# lines connecting identifiers
	else if(type == "t")
	{
		RNMGraphicsStopifnot(!is.null(idLabels))
		 
		if(!is.null(groups)) 
		{
			textopt <- getGraphParams("superpose.text")
			groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line"))
			groupInfo2 <- subjectGrouping(idLabels, groups, textopt, expand = TRUE)
			ltext(x, y, idLabels[subscripts], col = groupInfo2$elements$col[subscripts] ,
					groupInfo2$elements$cex[subscripts], ...)		
			panel.superpose(x, y, groups = groupInfo$grouping, type = "l", 
					subscripts = subscripts, col.line = groupInfo$elements$col,
					lty = groupInfo$elements$lty , lwd = groupInfo$elements$lwd,  ...)
		}
		else
		{
			plot.line <- getGraphParams("plot.line")
			textopt <- getGraphParams("plot.text")
			ltext(x, y, idLabels[subscripts], col = textopt$col , cex = textopt$cex , ...)
			groups <- idLabels
			panel.superpose(x = x, y = y, subscripts = subscripts, type = "l", 
					groups = idLabels, col.line = plot.line$col, lty = plot.line$lty, lwd = plot.line$lwd, ...) 
		}
	}

	if(featuresToAdd["loess"])
	{
		loessOpts <- getGraphParams("loess.line")
		# implement a try-catch just in case loess curve fails to compute correctly
		tryLoess <- try(panel.loess(x,y, col = loessOpts$col, lwd = loessOpts$lwd))
		if(inherits(tryLoess, "try-error"))
			RNMGraphicsWarning("Failed to calculate loess curve, omitting from this panel\n")
	}
}