# $Rev$
# $LastChangedDate$


#' Generates a set of scatter plots with features that are tailored for PK/PD data generated by NONMEM.
#' @name nmScatterPlot
#' @title NONMEM scatter plot
#' @param obj An object of class NMRun, NMProblem, or data.frame. The object from which data will be plotted.
#' @param xVars A character vector or comma-seperated string of x-variables. Names of the variables to plot on x-axes.
#' @param yVars Variables to plot on the y-axes, specified the same way as xVars
#' @param bVars “Trellis” variables on which to split data.
#' @param gVars “Grouping” variable – used to group points by colour, for legends and so on.  
#' @param iVars Variable name of the “inherent grouping” variable.  This affects plots whose type is "l", "i" or "t".
#' @param addLegend Should legends be added?
#' @param addGrid should grids be added?
#' @param addLoess should a loess smoother line be added? 
#' @param titles Plot title 
#' @param logX Should the x-axis be logged?
#' @param logY similar to logX for y axis
#' @param idLines Should reference lines of slope 1 and y-intercept 0 be added?
#' @param abLines Unused at the moment.
#' @param xLab x-axis labels.  By default, will use the names of the x-axis variables and their descriptions if any are available
#' via getVarDescription in RNMImport
#' @param yLab similar to the above, but for y-axis labels
#' @param doPlot Should the plot be plotted immediately, before returning it as an object?
#' @param types Plot types to use.  Allowed types are "p" (for standard points), "l" (lines connected by the variable
#' specified in "iVars", "i" for points labeled by "iVars", and "t" for labels connected by lines grouped by "iVars"
#' @param overlaid Logical flag. If TRUE, for each fixed x, the y variables will be overlaid onto a single plot
#' @param problemNum Number of the problem (applicable to NMRun class only)
#' @param subProblems Number of the simulation subproblems to use (applicable to the NMSim* classes obly)
#' @param yAxisRelations *
#' @param maxPanels *
#' @param xRotAngle Angle by which to rotate the x-axis tick marks
#' @param maxTLevels *
#' @param ... Additonal variables passed to the xyplot function 
#' @return An object of class multiTrellis holding the plot
#' @author fgochez
#' @keywords hplot

nmScatterPlot <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="", logX = NULL,
		logY = NULL, idLines = FALSE, abLines = NULL, xLab = NULL, yLab = NULL, 
		types = "p", overlaid = FALSE, equalAxisScales = FALSE ,layout = NULL, maxPanels = NULL, 
		maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"), xRotAngle = 0,
		problemNum = 1, subProblems = 1,
		...)
{
	RNMGraphicsStop("Not implemented for this class yet!")
}	
setGeneric("nmScatterPlot")

nmScatterPlot.NMRun <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="" , 
							logX = FALSE, logY = FALSE,idLines = FALSE,  abLines = NULL, xLab = NULL, 
							yLab = NULL, types = "p", overlaid = FALSE, equalAxisScales = FALSE ,
							layout = NULL, maxPanels = NULL, 
							maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"), 
							xRotAngle = 0, problemNum = 1, subProblems = 1, ...)
{
	prob <- getProblem(obj, problemNum)
	x <- as.list(match.call())
	x$obj <- prob
	do.call(nmScatterPlot, x[-1])
	
}

setMethod("nmScatterPlot", signature(obj = "NMRun"), nmScatterPlot.NMRun)


nmScatterPlot.NMProblem <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
							logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,xLab =NULL , yLab = NULL, 
							types = "p",  overlaid = FALSE, equalAxisScales = FALSE,  
							layout = NULL, maxPanels = NULL , 
							maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"),
							xRotAngle = 0, problemNum = 1, subProblems = 1,
							...)
{
	
	dataSet <- applyGraphSubset(nmData(obj, subProblemNum = subProblems), graphSubset(obj))
	x <- as.list(match.call())
	x$obj <- dataSet

	do.call(nmScatterPlot, x[-1])
	
}

nmScatterPlot.data.frame <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
		logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,  xLab = NULL, 
		yLab = NULL,  types = "p", overlaid = FALSE , 
		 equalAxisScales = FALSE,  layout = NULL, maxPanels = NULL ,  
		 maxTLevels = Inf, yAxisRelations = c("same", "free", "sliced"),
		 xRotAngle = 0,
		 problemNum = 1, subProblems = 1, ...)
{
	if(length(maxPanels) > 0) layout <- NULL
	# ensure that maxPanels is numeric, even if empty
	else maxPanels <- numeric(0)
	# extract xVars - currently only one is allowed
	xVars <- CSLtoVector(xVars)
	RNMGraphicsStopifnot(length(xVars) == 1, msg = "Multiple x variables are not allowed at the moment\n")
	yVars <- CSLtoVector(yVars)
	# extract the desired subset
	dataSet <- applyGraphSubset(obj, graphSubset(obj))
	# if the y-axis variables should be overlaid (rather than displayed side-by-side on lattice panels),
	# go straight to the .overlaidScatter function and return the result
	if(overlaid && length(yVars) > 1)
	{
		return(.overlaidScatter(obj =dataSet, xVars = xVars, yVars = yVars, bVars = bVars, 
						gVars = gVars, iVars = iVars, 
						addLegend = addLegend, addGrid = addGrid,
						addLoess = addLoess, titles = titles, logX = logX, 
						logY = logY, idLines = idLines, xLab = xLab,
						yLab = yLab, types = types, equalAxisScales = equalAxisScales,
						maxPanels = maxPanels, layout = layout, maxTLevels = maxTLevels, xRotAngle = xRotAngle, ...))
	}
	
	# take all combinations of x variables against y variables
	# NOTE: this logic is outdated and is related to the fact that lattice's extended formula functionality
	# was not being used to plot multiple x/y variables, but is now.  numCombos should always be 1 at the
	# moment
	# It is benign at the moment but confusing.
	# TODO: remove this
	
	varCombos <- varComboMatrix(xVars, yVars)
	numCombos <- nrow(varCombos)
	
	gVars <- if(!is.null(gVars)) CSLtoVector(gVars) else "NULL"
	# At the moment, only one gVar handled
	gVars <- gVars[1]
	titles <- rep(titles,numCombos)

	# assign and y labels, taking care to handle the case where they are missing
	# TODO: There is a quirk here in that xLab and yLab _cannot_ be a comma seperated list since empty strings
	# are currently deleted by CSLtoVector.  A workaround is needed for this, and documentation should
	# make clear thet CSLs are not allowed.  In any case, this is irrelevant since numCombos can only be 1
	if(!is.null(xLab))
		xLab <- rep(xLab, length.out = numCombos)
	else
		xLab <- varCombos[,1]
	if(!is.null(yLab))
		yLab <- rep(yLab, length.out = numCombos)
	else
		yLab <- varCombos[,2]
	
	# repeat these variables so that there is one entry for each combination. 
	repeatVars(c("addLegend", "addGrid", "addLoess", "titles", "logX", "logY", "idLines","types", "equalAxisScales"),
				list(addLegend, addGrid, addLoess, titles, logX, logY, idLines ,types, equalAxisScales), length.out = numCombos )

	iVars <- if(!is.null(iVars)) rep(CSLtoVector(iVars), length.out = numCombos) else rep("NULL", length.out = numCombos)
	
	plotFormulas <- apply(cbind(varCombos[,2], varCombos[,1] ), 1, paste, collapse = "~")
	# if there are "by variables", adjust the plotting formulas passed to xyplot
	if(!is.null(bVars))
	{
		bVars <- CSLtoVector(bVars)
		# bin the by-variables as necessary
		temp <- processTrellis(dataSet, bVars, maxLevels = maxTLevels, exempt = iVars)
		bVars <- temp$columns
		# coerce each "by" variable to a factor
		dataSet <- coerceToFactors(temp$data, bVars)
		# post-process the plot formulas by adding the trellis variables
		plotFormulas <- sapply(1:numCombos, function(i) paste(plotFormulas[i], paste(bVars, collapse = "+"), sep = "|"))
	}
	plotList <- vector(mode = "list", length = numCombos)
	graphParams <- getAllGraphParams()
	
	par.settings <- mapTopar.settings()
	stripfn <- getStripFun()
	
	for(i in seq_along(plotFormulas))
	{
		if(addLegend[i] & gVars != "NULL")
		{
			plotKey <- scatterPlotKey(getVarLabel(gVars), dataSet[[gVars]], type = types[i])
					# list(title = getVarDescription(gVars)$Label, rows = 10, cex=.7, space="right")
		}
		else plotKey <- NULL
		
		# get idLabels.  Note that these will have to be repeated if there is more than one yvar
		idLabels <- if(iVars[i] == "NULL") NULL else rep(dataSet[[iVars[i]]], length(yVars) ) 
		# initialize x axis label rotation to xRotAngle		
		scales <- list(x = list(rot = xRotAngle), y = list())
		
		# Here we check for integer data on the x-axis and y-axis.  If so, use integer tick marks.  
		# We remove missing data first just in case prior to performing this.  Note that the y-axis
		# is only handled if there is a single y variable, and this code is only executed if equal axis-scales
		# is set to false.
	
		if(!equalAxisScales)
		{
		
			if(!is.factor(dataSet[[xVars[i]]]) &&	all(na.omit(dataSet[[xVars[i]]] == round(dataSet[[xVars[i]]]))))			
				scales$x$at <- unique(round(pretty(dataSet[[xVars[i]]])))
			if(length(yVars) == 1 &&  !is.factor(dataSet[[yVars]]) &&	
					all(na.omit(dataSet[[yVars]] == round(dataSet[[yVars]]))))
				scales$y$at <- unique(round(pretty(dataSet[[yVars]])))
		
		}
		# log axes if necessary
		if(logX[i]) scales$x <- c( scales$x, list(log = "e"))
		if(logY[i]) scales$y <- c(scales$y, list(log = "e"))
		
		# if we are forcing the axis scales to be identical, we must pad out the range of the data since otherwise
		# clipping occurs
				
		if(equalAxisScales[i]) scales$limits <- padLimits(range(unlist(dataSet[c(xVars[i], yVars)]), na.rm=T))
		# only apply the yAxisRelations if there is reason to 
		if(length(yVars) > 1 || length(bVars) > 0) scales$y$relation <- match.arg(yAxisRelations)
		featuresToAdd <- c("grid" = addGrid[i], "loess" = addLoess[i], "idLine" = idLines[i])
		
		plotList[[i]] <- 
				with(graphParams, 
					xyplot(as.formula(plotFormulas[[i]]), groups = eval(parse(text = gVars)),  
					data = dataSet, panel = panel.nmScatterPlot, featuresToAdd = featuresToAdd, 
					key = plotKey, main = titles[[i]], idLabels = idLabels, scales =scales,
					xlab = xLab[i],	ylab = yLab[i],	type = types[i], 
					par.settings = par.settings, outer = TRUE, stack = FALSE, strip = stripfn, 
					layout = layout, multiYVar = length(yVars) > 1,...)
 				) # end with
	}
	gridDims <- stdGridDims(numCombos,3 )
	result <- multiTrellis(plotList, gridDims, maxPanels = maxPanels)
	result
}


setMethod("nmScatterPlot", signature(obj = "data.frame"), nmScatterPlot.data.frame)

setMethod("nmScatterPlot", signature(obj = "NMProblem"), nmScatterPlot.NMProblem)


#' nmScatterPlot panel function - this is used only when overlaid = FALSE 
#' @name panel.nmScatterPlot
#' @title nmScatterPlot panel function (1 of 2)
#' @param x (usual)
#' @param y  (usual)
#' @param subscripts (usual) 
#' @param featuresToAdd named logical vector of features to add (grid, loess, idLine) 
#' @param idLabels Identifier labels 
#' @param type one of "p", "i", "l", "o", "t"
#' @param groups (usual)
#' @param multiYVar currently unused
#' @param ... additional parameters to panel.xyplot
#' @return none
#' @author fgochez
#' @keywords

panel.nmScatterPlot <- function(x, y, subscripts = seq_along(x), featuresToAdd =  c("grid" = FALSE, "loess" = FALSE, "idLine" = FALSE), 
		idLabels = NULL, type = c("p", "i", "l", "o","t"), groups = NULL, multiYVar = FALSE, ...)
{
	type <- match.arg(type)
	# call panel.xyplot to setup first
	panel.xyplot(x, y, type = "n",...)
	if(featuresToAdd["grid"])
	{
		gridOpts <- getGraphParams("grid")
		panel.grid(h = -1, v = -1, col = gridOpts$col, alpha = gridOpts$alpha, lty = gridOpts$lty, 
					lwd = gridOpts$lwd)
	}
	reflineOpts <- getGraphParams("refline")
	if(featuresToAdd["idLine"])
		panel.abline(a = 0, b = 1)
	
	# grab "superpose.line" styles
	superpose.line.col <- getGraphParams("superpose.line")$col
	
	
	if(type == "p")
	{
		# points only
		panel.xyplot(x = x, y = y, subscripts = subscripts, type = type, groups,
					...)
			
	}
	# TODO: capture all line parameters
	else if(type == "l")
	{		
		groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line"))	
		if(is.null(groups))
		{
			plot.line <- getGraphParams("plot.line")
			panel.superpose(x, y, groups = idLabels, type = type, subscripts = subscripts, 
				col.line = plot.line$col, col.lwd = plot.line$lwd, lty = plot.line$lty, ...)
		}
		else
		{
			panel.superpose(x, y, groups = groupInfo$grouping, type = type, subscripts = subscripts, 
					col.line = groupInfo$elements$col, lty = groupInfo$elements$lty, lwd = groupInfo$elements$lwd, ...)
		}
			
	}
	# lines + points connecting subjects
	else if(type == "o")
	{
		RNMGraphicsStopifnot(!is.null(idLabels))
		groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line") )
		
		if(is.null(groups))
		{
			plot.line <- getGraphParams("plot.line")
			panel.xyplot(x, y, type = "p", subscripts = subscripts, ...)
			panel.superpose(x, y, groups = idLabels, 
				type = "l", subscripts = subscripts, col = plot.line$col, 
				lty = plot.line$lty, lwd = plot.line$lwd, ...)
		}
		else
		{
			panel.superpose(x, y, groups = groups, type = "p", subscripts = subscripts, ...)
			panel.superpose(x, y, groups = groupInfo$grouping, type = "l", subscripts = subscripts, 
					col.line = groupInfo$elements$col, lty = groupInfo$elements$lty, lwd = groupInfo$elements$lwd, ...)
		}
	}
	# subject identifiers
	else if(type == "i")
	{
		# TODO: allow use of "gVar"
		RNMGraphicsStopifnot(!is.null(idLabels))
		if(!is.null(groups))
		{
			textopt <- getGraphParams("superpose.text")
			groupInfo <- subjectGrouping(idLabels, groups, textopt, expand = TRUE)
			ltext(x, y, idLabels[subscripts], col = groupInfo$elements$col[subscripts] , cex = groupInfo$elements$cex[subscripts] , ...)
		}
		else
		{
			textopt <- getGraphParams("plot.text")
			ltext(x, y, idLabels[subscripts], col = textopt$col , cex = textopt$cex , ...)
		}
	}
	# lines connecting identifiers
	else if(type == "t")
	{
		RNMGraphicsStopifnot(!is.null(idLabels))
		 
		if(!is.null(groups)) 
		{
			textopt <- getGraphParams("superpose.text")
			groupInfo <- subjectGrouping(idLabels, groups, getGraphParams("superpose.line"))
			groupInfo2 <- subjectGrouping(idLabels, groups, textopt, expand = TRUE)
			ltext(x, y, idLabels[subscripts], col = groupInfo2$elements$col[subscripts] ,
					groupInfo2$elements$cex[subscripts], ...)		
			panel.superpose(x, y, groups = groupInfo$grouping, type = "l", 
					subscripts = subscripts, col.line = groupInfo$elements$col,
					lty = groupInfo$elements$lty , lwd = groupInfo$elements$lwd,  ...)
		}
		else
		{
			plot.line <- getGraphParams("plot.line")
			textopt <- getGraphParams("plot.text")
			ltext(x, y, idLabels[subscripts], col = textopt$col , cex = textopt$cex , ...)
			groups <- idLabels
			panel.superpose(x = x, y = y, subscripts = subscripts, type = "l", 
					groups = idLabels, col.line = plot.line$col, lty = plot.line$lty, lwd = plot.line$lwd, ...) 
		}
	}

	if(featuresToAdd["loess"])
	{
		loessOpts <- getGraphParams("loess.line")
		# implement a try-catch just in case loess curve fails to compute correctly
		tryLoess <- try(panel.loess(x,y, col = loessOpts$col, lwd = loessOpts$lwd))
		if(inherits(tryLoess, "try-error"))
			RNMGraphicsWarning("Failed to calculate loess curve, omitting from this panel\n")
	}
}