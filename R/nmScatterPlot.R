# $Rev$
# $LastChangedDate$


#' Generates a set of scatter plots with features that are tailored for PK/PD data generated by NONMEM.
#' @name nmScatterPlot
#' @title NONMEM scatter plot
#' @param obj An object of class NMRun, NMProblem, or data.frame. The object from which data will be plotted.
#' @param xVars A character vector or comma-seperated string of x-variables. Names of the variables to plot on x-axes.
#' @param yVars Variables to plot on the y-axes, specified the same way as xVars
#' @param bVars “Trellis” variables on which to split data.  Will be recycled for each x/y variable pair.
#' @param gVars “Grouping” variable – used to group points by colour, for legends and so on.  
#' Will be recycled for each x/y variable pair.
#' @param iVars Variable name of the “inherent grouping” variable.  This affects plots whose type is "l", "i" or "t".
#' @param addLegend Should legends be added?
#' @param addGrid should grids be added?
#' @param addLoess should a loess smoother line be added? 
#' @param titles Plot title for each x/y pair.  Optional
#' @param logX Should the x-axis be logged?  Recycled for each x/y pair 
#' @param logY similar to logX for y axis
#' @param idLines Should reference lines of slope 1 and y-intercept 0 be added? Recycled for each x/y pair
#' @param abLines Unused at the moment.
#' @param xLab x-axis labels.  By default, will use the names of the x-axis variables and their descriptions if any are available
#' via getVarDescription in RNMImport
#' @param yLab similar to the above, but for y-axis labels
#' @param doPlot Should the plot be plotted immediately, before returning it as an object?
#' @param types Plot types to use for each x/y pair.  Allowed types are "p" (for standard points), "l" (lines connected by the variable
#' specified in "iVars", "i" for points labeled by "iVars", and "t" for labels connected by lines grouped by "iVars"
#' @param overlaid Logical flag.  If TRUE, for each fixed x, the y variables will be overlaid onto a single plot
#' @param problemNum
#' @param subProblems
#' @param equalAxisScales
#' @param equaltYScales
#' @param ... Additonal variables passed to the xyplot function 
#' @return An object of class multiTrellis holding the plot
#' @author fgochez
#' @keywords hplot

# TODO: take out "doPlot" (code review)

nmScatterPlot <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="", logX = NULL,
		logY = NULL, idLines = FALSE, abLines = NULL, xLab = NULL, yLab = NULL, 
		doPlot = FALSE, types = "p", overlaid = FALSE, equalAxisScales = FALSE, equalYScales = TRUE,
		problemNum = 1, subProblems = 1,
		...)
{
	RNMGraphicsStop("Not implemented for this class yet!")
}	
setGeneric("nmScatterPlot")

nmScatterPlot.NMRun <- function( obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles="" , 
							logX = FALSE, logY = FALSE,idLines = FALSE,  abLines = NULL, xLab = NULL, 
							yLab = NULL, doPlot = FALSE, types = "p", overlaid = FALSE, equalAxisScales = FALSE ,
							equalYScales = TRUE, problemNum = 1, subProblems = 1, ...)
{
	prob <- getProblem(obj, problemNum)
	x <- as.list(match.call())
	x$obj <- prob
	do.call(nmScatterPlot, x[-1])
	
}

setMethod("nmScatterPlot", signature(obj = "NMRun"), nmScatterPlot.NMRun)


nmScatterPlot.NMProblem <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
							addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
							logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,xLab =NULL , yLab = NULL, 
							doPlot = FALSE, types = "p",  overlaid = FALSE, equalAxisScales = FALSE,  
							equalYScales = TRUE, problemNum = 1, subProblems = 1,
							...)
{
	
	dataSet <- nmData(obj, subProblems = subProblems)
	
	x <- as.list(match.call())
	x$obj <- dataSet
	
	do.call(nmScatterPlot.data.frame, x[-1])
	
}

# TODO: implement multiple grouping variables
# TODO: repetition of legend for each plot doesn't look great, but is difficult to solve. Consider
# moving this using grid graphics

nmScatterPlot.data.frame <- function(obj, xVars, yVars, bVars = NULL, gVars = NULL, iVars = "ID", 
		addLegend = FALSE, addGrid = TRUE, addLoess = FALSE, titles ="", 
		logX = FALSE, logY = FALSE, idLines = FALSE, abLines = NULL,  xLab = NULL, 
		yLab = NULL,  doPlot=FALSE, types = "p", overlaid = FALSE , 
		 equalAxisScales = FALSE, equalYScales = TRUE, problemNum = 1, subProblems = 1, ...)
{

	xVars <- CSLtoVector(xVars)
	yVars <- CSLtoVector(yVars)
	# TODO eliminate this copy
	dataSet <- obj
	
	if(overlaid)
	{
		return(.overlaidScatter(obj =dataSet, xVars = xVars, yVars = yVars, bVars = bVars, 
						gVars = gVars, iVars = iVars, 
						addLegend = addLegend, addGrid = addGrid,
						addLoess = addLoess, titles = titles, logX = logX, 
						logY = logY, idLines = idLines, xLab = xLab,
						yLab = yLab, doPlot = doPlot, types = types, equalAxisScales = equalAxisScales, ...))
	}
	# take all combinations of x variables against y variables
	
	varCombos <- varComboMatrix(xVars, yVars)
	numCombos <- nrow(varCombos)
	
	gVars <- if(!is.null(gVars)) CSLtoVector(gVars) else "NULL"
	# At the moment, only one gVar handled
	gVars <- gVars[1]
	titles <- rep(titles,numCombos)

	# assign and y labels, taking care to handle the case where they are missing
	# TODO: There is a quirk here in that xLab and yLab _cannot_ be a comma seperated list since empty strings
	# are currently deleted by CSLtoVector.  A workaround is needed for this, and documentation should
	# make clear thet CSLs are not allowed
	if(!is.null(xLab))
		xLab <- rep(CSLtoVector(xLab), length.out = numCombos)
	else
		xLab <- varCombos[,1]
	if(!is.null(yLab))
		yLab <- rep(CSLtoVector(yLab), length.out = numCombos)
	else
		yLab <- varCombos[,2]
	
	# repeat these variables so that there is one entry for each combination. 
	repeatVars(c("addLegend", "addGrid", "addLoess", "titles", "logX", "logY", "idLines","types", "equalAxisScales"),
				list(addLegend, addGrid, addLoess, titles, logX, logY, idLines ,types, equalAxisScales), length.out = numCombos )
	# retrieve iVar
	iVars <- if(!is.null(iVars)) rep(CSLtoVector(iVars), length.out = numCombos) else rep("NULL", length.out = numCombos)
	
	plotFormulas <- apply(cbind(varCombos[,2], varCombos[,1] ), 1, paste, collapse = "~")
	# if there are "by variables", adjust the plotting formuals passed to xyplot
	if(!is.null(bVars))
	{
		bVars <- CSLtoVector(bVars)
		dataSet <- coerceToFactors(dataSet, bVars)
		# coerce each "by" variable to a factor
		plotFormulas <- sapply(1:numCombos, function(i) paste(plotFormulas[i], paste(bVars, collapse = "+"), sep = "|"))
	}
	plotList <- vector(mode = "list", length = numCombos)
	graphParams <- getAllGraphParams()
	# This function is used in order to allow for "NULL" x and y labels
	# TODO: expand the keywords that may be used
	.nullIfnone <- function(x) { if (x == "@none") NULL else x }
	
	par.settings <- with(graphParams, list(
			plot.symbol =plot.symbol, superpose.symbol = superpose.symbol,
			par.xlab.text = axis.text, par.ylab.text = axis.text,
			par.main.text = title.text, plot.line = plot.line,
			add.line = refline, strip.background = strip.bg, 
			layout.widths = layout.widths, layout.heights = layout.heights)) 
	stripfn <- getStripFun()
	for(i in seq_along(plotFormulas))
	{
		if(addLegend[i] & gVars != "NULL")
			plotKey <- list(title = getVarDescription(gVars)$Label, columns = 3, cex=.7)
		else plotKey <- NULL
		
		# get idLabels.  Note that these will have to be repeated if there is more than one yvar
		idLabels <- if(iVars[i] == "NULL") NULL else rep(dataSet[[iVars[i]]], length(yVars) ) 
		
		scales <- list()
		# log axes if necessary
		if(logX[i]) scales$x <- list(log = "e", at = pretty(dataSet[[xVars[i]]]))
		if(logY[i]) scales$y <- list(log = "e", at = pretty(dataSet[[yVars[i]]]))
		# Set axes equal if required
		if (equalAxisScales[i]) scales$limits <- range(unlist(dataSet[c(xVars[i], yVars[i])]), na.rm=T)

		featuresToAdd <- c("grid" = addGrid[i], "loess" = addLoess[i], "idLine" = idLines[i])
	
		# TODO: dynamically calculate left and right padding

		plotList[[i]] <- 
				with(graphParams, 
					xyplot(as.formula(plotFormulas[[i]]), groups = eval(parse(text = gVars)),  
					data = dataSet, panel = panel.nmScatterPlot, featuresToAdd = featuresToAdd, 
					auto.key = plotKey, main = titles[[i]], idLabels = idLabels, scales =scales,
					xlab = xLab[i], 
					ylab = yLab[i], 
					type = types[i], 
					# TODO: move this logic out of the loop.  Also, wrap this in a function
					par.settings = par.settings, outer = TRUE, strip = stripfn, ...)
 				) # end with
	}
	gridDims <- stdGridDims(numCombos,3 )
	result <- multiTrellis(plotList, gridDims)
	result
}

	
setMethod("nmScatterPlot", signature(obj = "data.frame"), nmScatterPlot.data.frame)

setMethod("nmScatterPlot", signature(obj = "NMProblem"), nmScatterPlot.NMProblem)

# TODO: this is becoming a mess of if/else statements - is there a better way to do this?

panel.nmScatterPlot <- function(x, y, subscripts = seq_along(x), featuresToAdd =  c("grid" = FALSE, "loess" = FALSE, "idLine" = FALSE), 
		idLabels = NULL, type = c("p", "i", "l", "t"), groups = NULL, ...)
{
	type <- match.arg(type)
	# call panel.xyplot to setup first
	panel.xyplot(x, y, type = "n",...)
	if(featuresToAdd["grid"])
	{
		gridOpts <- getGraphParams("grid")
		panel.grid(h = -1, v = -1, col = gridOpts$col, alpha = gridOpts$alpha, lty = gridOpts$lty, 
					lwd = gridOpts$lwd)
	}
	reflineOpts <- getGraphParams("refline")
	if(featuresToAdd["idLine"])
		panel.abline(a = 0, b = 1)
	# TODO: add more comments
	# TODO: refactor the following to allow for groups and idlabels
	# if there was an iVar and the type is either "l" or "i", we need to use the ID var for grouping
	# note: use of gVar not allowed with type != "p"
	if(!is.null(idLabels) & (type != "p")) 
	{
		# TODO: implement type = "t"
		if(type == "l" ){
			if(!is.null(groups)) grouping <- paste(groups, idLabels, sep = ",") else grouping <- idLabels
			reqCol <- trellis.par.get(name = NULL)$superpose.line$col[1]
			# TODO: colours wrong at the moment
			panel.superpose(x, y, groups = grouping, type = type, subscripts = subscripts, col.line = reqCol, 
					, ...)
		}
		if(type == "i")	
		{
			textopt <- getGraphParams("plot.text")
			ltext(x, y, idLabels[subscripts], col = textopt$col , cex = textopt$cex , ...)
		}
	}
	else 
	{		
		
		if(!is.null(groups))
		{
			
			panel.superpose(x = x, y = y, subscripts = subscripts, type = type, groups = groups, 
					...)
		}
		else
			panel.xyplot(x = x, y = y, subscripts = subscripts, type = type, 
					...)
	}
	if(featuresToAdd["loess"])
	{
		loessOpts <- getGraphParams("loess.line")
		# implement a try-catch just in case loess curve fails to compute correctly
		tryLoess <- try(panel.loess(x,y, col = loessOpts$col, lwd = loessOpts$lwd))
		if(inherits(tryLoess, "try-error"))
			RNMGraphicsWarning("Failed to calculate loess curve, omitting from this panel\n")
	}
}